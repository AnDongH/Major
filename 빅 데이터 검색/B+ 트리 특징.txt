B+ 트리 특징

1. Block-based I/O

2. Multiple children

3. Balanced -> 모든 자식 노드들이 같은 깊이를 가지도록 완전 밸런싱

4. 모든 key 들은 리프 노드들에만 저장되어 있다.

5. 루트나 다른 인터널 노드들의 값에는 크기 비교를 위한 정보만 들어있음

6. Fanout = n = 포인터 개수 = 최대로 가질 수 있는 자식 수

7. 인터널 노드가 최대로 가지는 자식 수는 n/2의 상한값 ~ n개

8. 모든 리프 노드들이 가지는 값의 수는 (n-1)/2의 상한값 ~ n-1개

9. 루트 노드는 최소 2개의 자식 가짐

10. 만약 루트노드 = 리프노드일 시 값이 0 ~ n-1개까지 담을 수 있음

11. 리프노드의 포인터는 레코드, 버킷 값을 가리키고, 마지막 포인터는 아무것도 가리키지 않거나, 다음 리프노드를 가리킨다.

12. 중복값은 없다고 가정하고, 왼 -> 오로 갈 수록 값이 커진다.(반대도 마찬가지이지만 일관돼야함)

13. p(n-1), k(n-1), p(n-2), k(n-2) 이면 p(n-1) 에 연결되어있는 노드는 key들이 k(n-1)보다 작은 값들이여야 한다. 그리고 p(n-2) 에는 k(n-1) 이상 k(n-2) 보다 작은 값들이여야 한다.

14. B+ 트리의 최대 높이는 상한값(log(상한값(n/2), K)) 이다.

15. 검색 과정 -> 일반 트리처럼 루트부터 작으면 왼쪽, 크거나 같으면 오른쪽으로 들어가면서 탐색

16. 삽입 과정

(1) 새로운 키를 넣을 리프 노드까지 검색.
(2) harfRule을 유지하기 위해 노드들을 split 해준다.

-> 리프 부분 스플릿
-> 그 위 노드들 스플릿
-> 그 위 노드들 스플릿
.
.
.
.
-> 마지막 루트 노드 만들기

case1 : 루트 key 부분에 자리가 있을때 

루트가 다 찰 때까지는 루트에 삽입

case2 : 루트가 꽉 찼을 때

새로운 노드 만듬 -> 넣을 키 넣어줌 -> 
























