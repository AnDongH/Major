/*
 * Copyright(c) 2020-2023 All rights reserved by Heekuck Oh.
 * ì´ í”„ë¡œê·¸ë¨ì€ í•œì–‘ëŒ€í•™êµ ERICA ì»´í“¨í„°í•™ë¶€ í•™ìƒì„ ìœ„í•œ êµìœ¡ìš©ìœ¼ë¡œ ì œì‘ë˜ì—ˆë‹¤.
 * í•œì–‘ëŒ€í•™êµ ERICA í•™ìƒì´ ì•„ë‹Œ ìëŠ” ì´ í”„ë¡œê·¸ë¨ì„ ìˆ˜ì •í•˜ê±°ë‚˜ ë°°í¬í•  ìˆ˜ ì—†ë‹¤.
 * í”„ë¡œê·¸ë¨ì„ ìˆ˜ì •í•  ê²½ìš° ë‚ ì§œ, í•™ê³¼, í•™ë²ˆ, ì´ë¦„, ìˆ˜ì • ë‚´ìš©ì„ ê¸°ë¡í•œë‹¤.
 */
#ifdef __linux__
#include <bsd/stdlib.h>
#elif __APPLE__
#include <stdlib.h>
#else
#include <stdlib.h>
#endif
#include "mRSA.h"

/*
 * mod_add() - computes a + b mod m
 */
static uint64_t mod_add(uint64_t a, uint64_t b, uint64_t m)
{
	// ì„ì‹œ ë³€ìˆ˜ ì„ ì–¸ % m
	uint64_t r1 = a % m;
	uint64_t r2 = b % m;

	// ì˜¤ë²„ í”Œë¡œ ë‚˜ì§€ ì•Šë„ë¡ ì¡°ê±´
	return r1 < (m - r2) ? r1 + r2 : r1 - (m - r2);
}

/*
 * mod_mul() - computes a * b mod m
 */
static uint64_t mod_mul(uint64_t a, uint64_t b, uint64_t m)
{
	uint64_t r = 0;
	while (b > 0){
		// b ë¹„íŠ¸ê°€ 1ì´ë©´ ë”í•˜ê¸°
		if (b & 1) r = mod_add(r, a, m);
		b = b >> 1;
		// a*2ê°’ ëˆ„ì 
		a = mod_add(a,a,m);
	}
	return r;
}

/*
 * mod_pow() - computes a^b mod m
 */
static uint64_t mod_pow(uint64_t a, uint64_t b, uint64_t m)
{
	uint64_t r = 1;
	while (b > 0){
		// b ë¹„íŠ¸ê°€ 1ì´ë©´ ê³±í•˜ê¸°
		if (b & 1) r = mod_mul(r,a,m);
		b = b >> 1;
		// a^2ê°’ ëˆ„ì 
		a = mod_mul(a,a,m);
	} 
	return r;
}

/*
 * gcd() - Euclidean algorithm
 */
static uint64_t gcd(uint64_t a, uint64_t b)
{
 	 /* 
		 gcd(a, b) = gcd(b, a % b) ì™€ ê°™ìŒì„ ì´ìš©í•œ ë°©ì‹ì´ë‹¤.
   		 ì¬ê·€ í˜¸ì¶œì€ ì¼ë°˜ì ìœ¼ë¡œ ìŠ¤íƒì— ê³„ì†í•´ì„œ ë©”ëª¨ë¦¬ë¥¼ ìŒ“ì•„ê°€ê³ 
   		 ë‹¤ì‹œ ë³µê·€ì£¼ì†Œë¡œ ë¦¬í„´í•´ì£¼ëŠ” ê³¼ì •ì„ ê°€ì§€ê¸°ì— íŠ¹ë³„í•œ ê²½ìš°ê°€ ì•„ë‹ˆë¼ë©´
   		 ë°˜ë³µë¬¸ì´ ë” ë†’ì€ ì„±ëŠ¥ì„ ë°œíœ˜í•œë‹¤.

  		 ë§¤ ë°˜ë³µë§ˆë‹¤ a ì—ëŠ” bë¥¼ ë„£ê³ , bì—ëŠ” a % bë¥¼ ë„£ëŠ” ê³¼ì •ì„ ì§„í–‰í•œë‹¤.
  	*/ 	
	uint64_t tem;
	while(b != 0){
		tem = b;
		b = a % b;
		a = tem;
	}
	return a;
}

/*
 * mul_inv() - computes multiplicative inverse a^-1 mod m
 * It returns 0 if no inverse exist.
 */
static uint64_t mul_inv(uint64_t a, uint64_t m)
{
	// ë³€ìˆ˜ ì„¤ì •
	uint64_t d0 = a, d1 = m;
    uint64_t x0 = 1, x1 = 0, q, tem, t;
    int isNx0 = 0, isNx1 = 0, isNt = 0;
   	
	// d1 > 1ë™ì•ˆ
    while (d1 > 1){

		// dì˜ ê³„ì‚°ì€ ë™ì¼
    	q = d0 / d1; 
        tem = d0 - q * d1; 
        d0 = d1; 
        d1 = tem;
    
		// ì„ì‹œ ì €ì¥ ë³€ìˆ˜
		t = x1; isNt = isNx1;
		
		// x0ì™€ x1ì˜ ë¶€í˜¸ ë‹¤ë¥¸ì§€ ê°™ì€ì§€ ë¹„êµ
		if (isNx0 != isNx1){
			/*
		    	ë‹¤ë¥´ë‹¤ë©´ + ë¥¼ í•´ì£¼ê³  isNx1 = isNx0ìœ¼ë¡œ ë§ì¶°ì¤€ë‹¤.
			 	
				ë§Œì•½ isNx0 = 0, isNx1 = 1 ì¼ ê²½ìš°
				ì›ë˜ ì—°ì‚°ì€ - ì´ê³  -ì˜ -ëŠ” +ì´ë¯€ë¡œ +ë¥¼ í•´ì¤€ ë‹¤ìŒ
				isNx1 ì€ ì–‘ìˆ˜ê°€ ëœë‹¤.

				ë§Œì•½ isNx0 = 1, isNx1 = 0ì¼ ê²½ìš°
				ì›ë˜ ì—°ì‚°ì€ - ì´ê³  ì´ëŠ”  ë‘ ê°’ì„ ë”í•´ì¤€ ë‹¤ìŒ
				ìŒìˆ˜ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ê²ƒê³¼ ê°™ê¸°ì— ë”í•´ì¤€ í›„
				isNx1 ì€ ìŒìˆ˜ê°€ ëœë‹¤.
			*/
			
			x1 = x0 + q * x1;
			isNx1 = isNx0;
		}
		else{
			// ë‘ ë¶€í˜¸ê°€ ê°™ë‹¤ë©´ ë‘ ê°’ì„ ë¹„êµí•´ì¤˜ì•¼ í•œë‹¤.	
			// x0ê°€ ë” í° ê°’ì´ë©´ ê¸°ì¡´ ì—°ì‚°ê³¼ ê°™ê³  x1ì€ ë¬´ì¡°ê±´ ì–‘ìˆ˜
			// q * x1ì´ ë” í¬ë‹¤ë©´ ë°˜ëŒ€ë¡œ ê³„ì‚°í•´ì£¼ê³  x1ì€ ë¬´ì¡°ê±´ ìŒìˆ˜
			x1 = (x0 > q * x1) ? x0 - q * x1 : q * x1 - x0;
			isNx1 = (x0 > q * x1) ? 0 : 1;  
		}
		// x0ëŠ” ë¯¸ë¦¬ ì €ì¥í•´ì¤€ ê¸°ì¡´ x1ê°’ì—  ë§ì¶° ëŒ€ì…í•´ì¤€ë‹¤.
		// ì—¬ê¸°ê¹Œì§€ì˜ ê³¼ì •ì´ ê¸°ì¡´ì˜
        // tem = x0 - q * x1; x0 = x1; x1 = tem;  ì‘ì—…ì´ë‹¤.
		x0 = t; isNx0 = isNt;
    }
    // ì„œë¡œì†Œì¸ì§€ í™•ì¸
    if (d1 == 1){
		// isNx1ì˜ ë¶€í˜¸ë¥¼ í™•ì¸í•˜ê³  ìŒìˆ˜ë©´ mìœ¼ë¡œ ë¹¼ì¤€ë‹¤.
        // (ê¸°ì¡´ì˜ m + x1ê³¼ ë™ì¼í•œ ê²°ê³¼)
		// ì–‘ìˆ˜ë¼ë©´ ê·¸ëƒ¥ x1ì„ ë¦¬í„´í•œë‹¤.
    	return (isNx1 > 0 ? m - x1 : x1);
    }
    else
    	return 0;
}

/*
 * Miller-Rabin Primality Testing against small sets of bases
 *
 * if n < 2^64,
 * it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, and 37.
 *
 * if n < 3317044064679887385961981,
 * it is enough to test a = 2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, and 41.
 */
static const uint64_t a[BASELEN] = {2,3,5,7,11,13,17,19,23,29,31,37};

/*
 * miller_rabin() - Miller-Rabin Primality Test (deterministic version)
 *
 * n > 3, an odd integer to be tested for primality
 * It returns 1 if n is prime, 0 otherwise.
 */
static int miller_rabin(uint64_t n)
{
	// ë³€ìˆ˜ ì„¤ì •
	uint64_t q = n - 1, tem, p, a_val;
	
	// 2ë³´ë‹¤ ì‘ê±°ë‚˜, 2 ì œì™¸ ì§ìˆ˜ëŠ” ì†Œìˆ˜ ì•„ë‹˜
	if (n < 2 || (n != 2 && n % 2 == 0)) return COMPOSITE;
	
	// q êµ¬í•˜ê¸°
	while (q % 2 == 0) q /= 2;
	
	// aê°’ë“¤ë§Œí¼ ë°˜ë³µ
	for (int i = 0; i < BASELEN; i++){
		// aê°’ì´ nê³¼ ê°™ë‹¤ë©´ ì†Œìˆ˜
		if((a_val = a[i]) == n) return PRIME;
	
		tem = q;
		
		// a^q ê°€ 1ì´ë¼ë©´ ë‹¤ìŒ ë°˜ë³µë¬¸ í™•ì¸
		if ((p = mod_pow(a_val, tem, n)) == 1) continue;		
		
		// 0 ~ k - 1ê¹Œì§€ pê°€ n - 1ì¸ì§€ í™•ì¸
		while(tem != n - 1 && p != n - 1){
			p = mod_mul(p, p, n);
			tem *= 2;
		} 

		// tem == n - 1 ì´ë¼ì„œ ëë‚¬ë‹¤ë©´ ì¡°ê±´ë¬¸
		if (p != n - 1){
			return COMPOSITE;
		}
	}
	
	// ëª¨ë‘ ë¬¸ì œ ì—†ì´ ëë‚¬ë‹¤ë©´ ì†Œìˆ˜
	return PRIME;
}

/*
 * mRSA_generate_key() - generates mini RSA keys e, d and n
 *
 * Carmichael's totient function Lambda(n) is used.

ê³µê°œí‚¤ PU{e, n} ê³¼, ê°œì¸í‚¤ PR{d, n} ì„ êµ¬í•˜ëŠ” í•¨ìˆ˜ì´ë‹¤. 
ë¨¼ì € ë‘ ì†Œìˆ˜ pì™€ qì˜ ê³±ìœ¼ë¡œ nì„ ë§Œë“¤ê¸° ìœ„í•´ì„œ pì™€ që¥¼ ëœë¤ìœ¼ë¡œ ë½‘ëŠ”ë‹¤. 
ì´ë•Œ nì€ ë¬´ì¡°ê±´ 2^63 <= n < 2^64 ì˜ ì¡°ê±´ì„ ë§Œì¡±í•´ì•¼ í•˜ê¸°ì— 
ì—¬ëŸ¬ë²ˆ ë½‘ì•„ë³´ë©´ì„œ ì¡°ê±´ì„ ë§Œì¡±í•˜ëŠ”ì§€ ì²´í¬í•´ì•¼ í•œë‹¤.

ì•ˆì „í•˜ê²Œ ëœë¤ìœ¼ë¡œ ë½‘ê¸° ìœ„í•´ì„œ 32ë¹„íŠ¸ ì •ìˆ˜ë¥¼ ë¦¬í„´í•´ì£¼ëŠ” arc4random(); í•¨ìˆ˜ë¥¼ ì´ìš©í•´ì¤€ë‹¤.

ê° pì™€ që¥¼ ë½‘ì•„ì„œ ë‘ ìˆ˜ì˜ ë§¨ ì™¼ìª½ê³¼ ì˜¤ë¥¸ìª½ ë¹„íŠ¸ë¥¼ 1ë¡œ ë°”ê¾¸ëŠ”ë° 
ì´ëŠ” í•´ë‹¹ ìˆ˜ë¥¼ í™€ìˆ˜ë¡œ ë§Œë“¤ì–´ì£¼ëŠ” ê²ƒì˜ ì˜ë¯¸í•˜ê³  ê·¸ í¸ì´ ìœ ë¦¬í•˜ë‹¤. 
ì´ìœ ëŠ” 2ê°€ ì•„ë‹Œ ì§ìˆ˜ëŠ” ì†Œìˆ˜ê°€ ì•„ë‹ˆê¸° ë•Œë¬¸ì´ë‹¤. 
ë‘ë²ˆì§¸ë¡œ ê·¸ëƒ¥ pì™€ që¥¼ êµ¬í•˜ê³  ê³„ì† ì†Œìˆ˜ì¸ì§€ íŒì •í•´ë³´ê³  
ì†Œìˆ˜ì´ë©´ ê³±í•´ë´¤ì„ ë•Œ í•´ë‹¹ ìˆ˜ê°€ 2^63 ì´ìƒì¸ì§€ë¥¼ íŒë‹¨í•´ì•¼ í•˜ëŠ”ë°, 
ë§¨ ì™¼ìª½ ë¹„íŠ¸ë¥¼ 1ë¡œ ë°”ê¾¸ì§€ ì•Šê³  ê³„ì‚°ì„ í–ˆì„ ë•Œ ê·¸ ì†ë„ê°€ êµ‰ì¥íˆ ëŠë ¸ë‹¤. 
pì™€ qëŠ” ë°˜ë“œì‹œ 32ë¹„íŠ¸ì¼ í•„ìš”ëŠ” ì—†ì§€ë§Œ, 
ë‘˜ ë‹¤ 32ë¹„íŠ¸ë¡œ í–ˆì„ ë•Œ ì¡°ê±´ì— ë§ëŠ” pì™€ që¥¼ ì°¾ëŠ” ì†ë„ê°€ ë¹„ì•½ì ìœ¼ë¡œ ë¹¨ë¼ì§ì„ í™•ì¸í•  ìˆ˜ ìˆì—ˆë‹¤.

ë”°ë¼ì„œ ë‘ ìˆ˜ì˜ ë§¨ ì™¼ìª½ ë¹„íŠ¸ë¥¼ 1ë¡œ ë§Œë“¤ì—ˆë‹¤. 
ë”êµ°ë‹¤ë‚˜ pì™€ qê°€ ë¹„ìŠ·í•œ ê¸¸ì´ì¼ìˆ˜ë¡ ì•ˆì •ì„±ì´ ë†’ì•„ì§„ë‹¤ê³  í•˜ë‹ˆ 
ì—¬ëŸ¬ëª¨ë¡œ ì´ë“ì´ ë§ì„ ê±°ë¼ê³  íŒë‹¨í–ˆë‹¤.
32ë¹„íŠ¸ ì •ìˆ˜ëŠ” ìµœëŒ€ 2^32 - 1ì´ê³  (2^32 â€“ 1) * (2^32 â€“ 1) = 2^64 â€“ 1ì´ë‹ˆ 
p*qëŠ” í•­ìƒ 2^64 ë³´ë‹¤ ì‘ì•„ì„œ ì˜¤ë²„í”Œë¡œë¥¼ ê±±ì •í•  í•„ìš”ë„ ì—†ë‹¤.

ì´ì œ ê°’ì„ ê³„ì‚°í•´ì£¼ê³  2^63 ì´ìƒì´ë©´ í•´ë‹¹ ì¡°ê±´ì„ ë„˜ì–´ê°€ ì¤€ë‹¤.

ì´í›„ì— nê°’ì€ ê³„ì‚°í•´ì¤€ sê°’ìœ¼ë¡œ ë„£ê³ , ì¹´ë§ˆì´í´ í•¨ìˆ˜ë¥¼ í†µí•´ì„œ ğœ†(ğ‘›)ë¥¼ êµ¬í•´ì¤€ë‹¤.
ì´ëŠ” p â€“ 1ê³¼ q â€“ 1ì˜ ìµœì†Œê³µë°°ìˆ˜ì´ë‹¤.
ì´í›„ 1 < e < ğœ†(ğ‘›) ì¡°ê±´ì— ë§ê³ , gcd(e, ğœ†(ğ‘›)) == 1 ì¦‰ ì„œë¡œì†Œë¥¼ ë§Œì¡±í•˜ëŠ” eë¥¼ ì°¾ê¸° ìœ„í•´ì„œ 
2 ë¶€í„° ğœ†(ğ‘›)ê¹Œì§€ ë°˜ë³µë¬¸ì„ ëŒë ¤ì¤€ë‹¤. 
eë¥¼ ì°¾ì•˜ë‹¤ë©´ ë°˜ë³µë¬¸ì„ ë©ˆì¶”ê³  eì˜ ëª¨ë“ˆëŸ¬ ğœ†(ğ‘›)ì— ëŒ€í•œ ì—­ì›ì¸ dë¥¼ êµ¬í•´ì£¼ëŠ” ê²ƒìœ¼ë¡œ
e, d, nê°’ì„ ëª¨ë‘ êµ¬í•´ì¤„ ìˆ˜ ìˆë‹¤.

ì´ë ‡ê²Œ êµ¬í•´ì§„ (e,n)ì€ ê³µê°œí‚¤ë¡œ ì•”í˜¸í™”ì— ì“°ì´ê³  (d,n)ì€ ê°œì¸í‚¤ë¡œ ë³µí˜¸í™”ì— ì“°ì¸ë‹¤.
(ë°˜ëŒ€ë„ ê°€ëŠ¥) 

 */
void mRSA_generate_key(uint64_t *e, uint64_t *d, uint64_t *n)
{
	// ë³€ìˆ˜ ì„¤
	uint64_t p, q, s, l;

	while (1){
		// p ëœë¤ìœ¼ë¡œ ë½‘ì•„ì„œ í™€ìˆ˜ + 32ë¹„íŠ¸ë¡œ ë³€ê²½
		p = arc4random(); p |= 0x80000001;

		// pëŠ” ì†Œìˆ˜ì¸ê°€?
		if (miller_rabin(p) != PRIME) continue;
		
		// q ëœë¤ìœ¼ë¡œ ë½‘ì•„ì„œ í™€ìˆ˜ + 32ë¹„íŠ¸ë¡œ ë³€ê²½
		q = arc4random(); q |= 0x80000001;

		// qëŠ” ì†Œìˆ˜ì¸ê°€?
		if (miller_rabin(q) != PRIME) continue;

		// nê°’ êµ¬í•˜ê¸°
		s = p * q;

		// nì´ 2^63ë³´ë‹¤ ì‘ì€ê°€?
		if (s < 0x8000000000000000) continue;
		
		break;
	}

	// nì— ë³µì‚¬
	*n = s;

	// ì¹´ë§ˆì´í´ í•¨ìˆ˜
	l = ((p-1)*(q-1)) / gcd(p-1,q-1);
	
	// e ì°¾ê¸°
	for (int i = 2; i < l; i++){
		if (gcd(i,l) == 1){
			*e = i;
			break;
		}
	}

	// ëª¨ë“ˆëŸ¬ ì—­ì›ìœ¼ë¡œ d ì°¾ê¸°
	*d = mul_inv(*e, l);
}

/*
 * mRSA_cipher() - compute m^k mod n
 *
 * If data >= n then returns 1 (error), otherwise 0 (success).

ì•”í˜¸í™”ì™€ ë³µí˜¸í™”ì¸ m^k mod nì„ í•´ì£¼ëŠ” í•¨ìˆ˜ë¥¼ êµ¬í˜„í•œë‹¤.
mì€ ë¬´ì¡°ê±´ në³´ì •ë‹¤ ì‘ì•„ì•¼ í•˜ê¸°ì— ë§Œì•½ ë” í¬ë‹¤ë©´ 
ë‚œìˆ˜ë¡œ ë½‘ì€ mì´ ë„ˆë¬´ í¬ë‹¤ë©° 1ì„ ë¦¬í„´í•´ì£¼ê³ , 
ê·¸ë ‡ì§€ ì•Šë‹¤ë©´ mod_powë¡œ m^k mod në¥¼ ê³„ì‚°í•˜ê³  0ì„ ë¦¬í„´í•´ì¤€ë‹¤.

 */
int mRSA_cipher(uint64_t *m, uint64_t k, uint64_t n)
{
	if (*m >= n) return 1;
	*m = mod_pow(*m, k, n);
	return 0;
}









